
import { supabase } from "@/integrations/supabase/client";
import { Issue } from "@/types";
import { mapDbIssueToAppIssue } from "./issueUtils";

export async function getIssueById(id: string): Promise<Issue | null> {
  try {
    const { data: issue, error } = await supabase
      .from('issues')
      .select('*')
      .eq('id', id)
      .single();
    
    if (error) {
      console.error("Error fetching issue:", error);
      return null;
    }
    
    // Fetch comments for this issue
    const { data: comments } = await supabase
      .from('issue_comments')
      .select('*')
      .eq('issue_id', id)
      .order('created_at', { ascending: true });
    
    return mapDbIssueToAppIssue(issue, comments || []);
  } catch (error) {
    console.error("Error in getIssueById:", error);
    return null;
  }
}

export async function getIssuesByUserId(userId: string): Promise<Issue[]> {
  try {
    const { data: issues, error } = await supabase
      .from('issues')
      .select('*')
      .eq('employee_uuid', userId)
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error("Error fetching user issues:", error);
      return [];
    }
    
    // For each issue, fetch its comments
    const issuesWithComments = await Promise.all(
      issues.map(async (issue) => {
        const { data: comments } = await supabase
          .from('issue_comments')
          .select('*')
          .eq('issue_id', issue.id)
          .order('created_at', { ascending: true });
        
        return mapDbIssueToAppIssue(issue, comments || []);
      })
    );
    
    return issuesWithComments;
  } catch (error) {
    console.error("Error in getIssuesByUserId:", error);
    return [];
  }
}

// Process issues function for filtering and sorting issues
export async function processIssues(dbIssues: any[]): Promise<Issue[]> {
  try {
    // Process each issue to include its comments
    const processedIssues = await Promise.all(
      dbIssues.map(async (issue) => {
        const { data: comments } = await supabase
          .from('issue_comments')
          .select('*')
          .eq('issue_id', issue.id)
          .order('created_at', { ascending: true });
        
        return mapDbIssueToAppIssue(issue, comments || []);
      })
    );
    
    return processedIssues;
  } catch (error) {
    console.error("Error processing issues:", error);
    return [];
  }
}

export async function createIssue(issueData: any): Promise<Issue | null> {
  try {
    // Fixed: Using .insert() with an array format instead of a single object
    // and removed the id field which is auto-generated by the database
    const { data, error } = await supabase
      .from('issues')
      .insert([{  // Using array format
        employee_uuid: issueData.employeeUuid,
        type_id: issueData.typeId,
        sub_type_id: issueData.subTypeId,
        description: issueData.description,
        status: 'open',
        priority: issueData.priority || 'medium',
      }])
      .select()
      .single();
    
    if (error) {
      console.error("Error creating issue:", error);
      return null;
    }
    
    return mapDbIssueToAppIssue(data);
  } catch (error) {
    console.error("Error in createIssue:", error);
    return null;
  }
}

export async function updateIssueStatus(
  issueId: string, 
  newStatus: Issue["status"],
  adminId?: string
): Promise<Issue | null> {
  try {
    // Get current date
    const now = new Date().toISOString();
    
    // Prepare update data
    const updateData: any = {
      status: newStatus,
      updated_at: now,
    };
    
    // If status is "closed", set closed_at timestamp
    if (newStatus === "closed") {
      updateData.closed_at = now;
    }
    
    // Update the issue
    const { data: updatedIssue, error } = await supabase
      .from('issues')
      .update(updateData)
      .eq('id', issueId)
      .select()
      .single();
    
    if (error) {
      console.error("Error updating issue status:", error);
      return null;
    }
    
    // If admin ID is provided, add a comment about status change
    if (adminId) {
      const statusMap: Record<string, string> = {
        open: "Open",
        in_progress: "In Progress",
        resolved: "Resolved",
        closed: "Closed"
      };
      
      try {
        await supabase
          .from('issue_comments')
          .insert([{
            issue_id: issueId,
            employee_uuid: adminId,
            content: `Status changed to: ${statusMap[newStatus] || newStatus}`,
            system_generated: true,
            created_at: now
          }]);
      } catch (commentError) {
        console.error("Error adding status comment:", commentError);
      }
    }
    
    // Fetch comments for this issue to return complete data
    const { data: comments } = await supabase
      .from('issue_comments')
      .select('*')
      .eq('issue_id', issueId)
      .order('created_at', { ascending: true });
    
    return mapDbIssueToAppIssue(updatedIssue, comments || []);
  } catch (error) {
    console.error("Error in updateIssueStatus:", error);
    return null;
  }
}

// Update the assignIssueToUser function to handle "unassigned" value
export async function assignIssueToUser(
  issueId: string, 
  assigneeId: string,
  adminId?: string
): Promise<Issue | null> {
  try {
    // Get current date
    const now = new Date().toISOString();
    
    // Prepare update data - handle "unassigned" special case
    const updateData: any = {
      assigned_to: assigneeId === "unassigned" ? null : assigneeId,
      updated_at: now,
    };
    
    // Update the issue
    const { data: updatedIssue, error } = await supabase
      .from('issues')
      .update(updateData)
      .eq('id', issueId)
      .select()
      .single();
    
    if (error) {
      console.error("Error assigning issue:", error);
      return null;
    }
    
    // Add a system comment about the assignment change
    if (adminId) {
      try {
        const commentContent = assigneeId === "unassigned" 
          ? "Issue unassigned" 
          : `Issue assigned to ${assigneeId}`;
          
        await supabase
          .from('issue_comments')
          .insert([{
            issue_id: issueId,
            employee_uuid: adminId,
            content: commentContent,
            system_generated: true,
            created_at: now
          }]);
      } catch (commentError) {
        console.error("Error adding assignment comment:", commentError);
      }
    }
    
    // Fetch comments for this issue to return complete data
    const { data: comments } = await supabase
      .from('issue_comments')
      .select('*')
      .eq('issue_id', issueId)
      .order('created_at', { ascending: true });
    
    return mapDbIssueToAppIssue(updatedIssue, comments || []);
  } catch (error) {
    console.error("Error in assignIssueToUser:", error);
    return null;
  }
}
